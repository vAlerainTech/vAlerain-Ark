//  IDA configuration file

//
//  PLEASE READ THIS NOTICE CAREFULLY
//  ---------------------------------
//
//      Configuration file is read 2 times.
//      First pass is performed as soon as IDA is loaded
//      Second pass is performed when IDA determines the processor type
//
//      All processor specific tuning is located at the second part of this file.
//
//      Please note that some parameters occur several times in the file:
//        each occurence for different processor.
//
//      User-specific tuning can be made in idauser.cfg file
//                      (see end of this file)
//
//      You may temporarily change a configuration variable by using
//      command line switches: -d and -D
//      The -d switch is processed at the first  configuration pass.
//      The -D switch is processed at the second configuration pass.
//      Example:
//                ida -dVPAGESIZE=0x4000 -c newfile
//
//      C-like preprocessor directives are allowed.
//      You can use C-like constants in this file.
//

//=========================================================================
//                      F I R S T   P A S S
//=========================================================================
//
//      First pass.
//      Define file extension table, memory sizes, screen mode
//      and OS specific parameters.
//
//-------------------------------------------------------------------------
#ifdef ____             // first pass of config starts here
//
//      Default processor configuration table
//      -------------------------------------
//
//      The default processor will be used if the processor type is
//      not specified in the command line.
//      Feel free to customize this table.
//
DEFAULT_PROCESSOR = {
/* Extension    Processor */
  "com" :       ""                      // IDA will try the specified
  "exe" :       ""                      // extensions if no extension is
  "dll" :       ""                      // given.
  "drv" :       ""
  "sys" :       ""
  "bin" :       ""                      // Empty processor means the default processor
  "ovl" :       ""
  "ovr" :       ""
  "ov?" :       ""
  "nlm" :       ""
  "lan" :       ""
  "dsk" :       ""
  "obj" :       ""
  "prc" :       "68000"                 // PalmPilot programs
  "axf" :       "arm"
  "h68" :       "68000"                 // MC68000 for *.H68 files
  "i51" :       "8051"                  // i8051   for *.I51 files
  "sav" :       "pdp11"                 // PDP-11  for *.SAV files
  "rom" :       "z80"                   // Z80     for *.ROM files
  "cla*":       "java"
  "s19":        "6811"
  "epoc":       "arm"
  "o":          ""
  "*":          ""                      // Any other extension
}

// The desired target device.
// In some cases, chips belong to the same processor family but use
// different memory layout, I/O ports, etc. By default, at the database
// creation time, IDA displays a dialog box with the list of the
// availabe devices for the current processor. The DEVICE parameter
// can be used to skip this dialog and silently use the specified device.
// If DEVICE=="NONE", then no device will be selected.
// This parameter can be conveniently used in the command line. Example:
//   ida -pavr -DDEVICE=\"AT90C8534\" input_file
DEVICE                  = ""

WORKDIR                 = ""            // Work directory. IDA will create
                                        // temporary database files there.
                                        // Set to a directory on a separate disk
                                        // to improve speed for huge databases.
APPEND_IDB_EXT          = YES           // When constructing a database name
                                        // from input file name: just append idb
                                        // extension to the input file name
                                        // (e.g. dir.exe -> dir.exe.idb)
                                        // or replace the existing extension
                                        // (dir.exe -> dir.idb)

// Plugins to automatically launch when opening an existing idb file.
// Currently we autorun the 'windbg' plugin to display Windows Crash Dump files.
AUTORUN_PLUGINS =
{
/* FileType        Plugin and argument */
#ifdef __NT__
  "windmp" :       "windbg_user:-2"
#endif
}

//
//      Memory configuration parameters
//      -------------------------------
// NOTES:
//
//      1. DATABASE_MEMORY determines how much memory will be allocated
//         for names, strings, xrefs, functions, etc. If it is == 0 then
//         IDA uses the following alrogithm:
//
//              DATABASE_MEMORY = new_file
//                              ? input_file_size * 4
//                              : old_btree_size/2
//         IDA never allocates more than 128MB in this case.
//
//      2. page sizes (VPAGESIZE and NPAGESIZE) must be powers of 2.
//
//      3. if VPAGES == 0 then 32bit IDA reserves memory by the following
//         alrogithm:
//
//              VMEM = new_file
//                              ? input_file_size*4
//                              : allocated_addressing_space;
//
//              VPAGES = VMEM / VPAGESIZE
//
//      4. Here is the total amount of memory allocated when IDA starts:
//
//           TOTAL = DATABASE_MEMORY + VPAGESIZE*VPAGES + NPAGESIZE*NPAGES
//


DATABASE_MEMORY         = 0             // Size of btree buffer in bytes.
VPAGESIZE               = 8192          // Virtual memory page size
                                        // (effective for new bases only)
                                        // 8192 => 128MB addressing space is the limit
VPAGES                  = 0             // Size of virtual memory window
                                        // (in pages)
NPAGESIZE               = 8192          // Name pointers page size
                                        // (effective for new bases only)
NPAGES                  = 32            // how big will be the memory buffer?
                                        // (each name uses 4 bytes)
                                        // The default settings allow to keep
                                        // in memory 2^16 names. The remaining
                                        // names will be swapped to the disk.

// Range of addresses reserved for internal use (idainfo::privrange) for new databases:
//   PRIVRANGE={start_ea, size} or PRIVRANGE=start_ea (default size=0x800000)
#ifdef __EA64__
PRIVRANGE               =  { 0xFF00000000000000, 0x800000 }
#else
PRIVRANGE               =  0xFF000000
#endif

// Undo related parameters
UNDO_MAXSIZE            = 0x8000000     // 128MB for undo buffers. once we reach
                                        // this limit, undo info about the most
                                        // ancient action will be deleted.
UNDO_DEPTH              = 1000000       // 1 million undoable actions. once we reach
                                        // this limit, undo info about the most
                                        // ancient action will be deleted.
UNDO_DURING_AA          = YES           // undo is available during initial analysis

// limit the xref cache size to this amount of entries,
// each entry takes 48..65 bytes depending on the platform
// (0 to disable the limit)
XREF_CACHE_COUNT = 0


// A semicolon-separated list of path elements, to be looked into
// for separate (i.e., 'companion') debug ELF files.
// The algorithm IDA uses for looking up companion files, is the same as GDB's
// <http://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-Files.html>
//
// Let:
//   PATH      be for-each components of the full ELF_DEBUG_FILE_DIRECTORY.
//   BIN       be the full path to the binary file.
//   DLINK     the value of the section ".gnu_debuglink"
//   BLDID     the value of the section ".note.gnu.build-id"
//      BLDCAR the lowercase hex-formatted value of the first byte of BLDID
//      BLDCDR the lowercase hex-formatted value of the remaining bytes of BLDID
//
// 1) If build ID present, look for file by build ID
//    foreach PATH in ELF_DEBUG_FILE_DIRECTORY:
//        if $PATH/.build-id/$BLDCAR/$BLDCRD.debug exists and matches:
//            found!
// 2) If not found, and debug link present, look for file by debug link
//    if dir($BIN)/$DLINK exists and matches:
//        found!
//    if dir($BIN)/.debug/$DLINK exists and matches:
//        found!
//    foreach PATH in ELF_DEBUG_FILE_DIRECTORY:
//        if $PATH/dir($BIN)/$DLINK exists and matches:
//            found!
//
// E.g., "/opt/debug-files;/opt/3rd-party-debug-files"
//
// WARNING: debug servers, do not use this file, and consequently will not
// pick up the value below. To override the debug server's default value
// pass it as an environment variable of the same name. I.e.,
//
//   ELF_DEBUG_FILE_DIRECTORY="/opt/debug-files;/opt/3rd-party-debug-files" ./linux_server64
//

#ifdef __LINUX__
ELF_DEBUG_FILE_DIRECTORY = "/usr/lib/debug";
#else
ELF_DEBUG_FILE_DIRECTORY = "";
#endif


// the following maps a character encoding, to one (or many)
// associated 'culture'(s).
//
// This is used to decide what codepoints should automatically be
// added to the sets of codepoints that contain the CURRENT_CULTURE
// entry, in case the IDB has a single-byte (and non-UTF-8) encoding.
// (See StrlitChars, etc... for more info.)
//
// Note: if a 'CULTURE' configuration directive is specified, it will
// override the culture(s) derived from the encoding.
//
// Note: the encodings below that consist of only a number, are considered
// windows ANSI codepages, and will map to multiple encodings whose
// names contain that codepage. E.g., 1252 will map to: "windows-1252",
// "windows1252", "cp1252", "1252".
ENCODING_CULTURES =
        1250: Central_Europe,
        1251: Cyrillic,
        1252: Latin_1,
        1253: Greek,
        1254: Turkish,
        1255: Hebrew,
        1256: Arabic,
        1257: Baltic,
        1258: Vietnam,
        874: Thai,
        932: Japanese,
        936: Chinese,
        949: Korean,
        950: Chinese,
        GB2312: Chinese,
        cp863: Latin_1 Greek;


//-------------------------------------------------------------------------
// The following drives the upgrade of pre-7.0 databases, regarding the
// conversion of non-ASCII user strings (comments, identifiers, etc...)
// This does not affect string literals in any way.
//-------------------------------------------------------------------------

// In case UPGRADE_CPSTRINGS_SRCENC[A] (see below) is not specified,
// should IDA warn (in the "Output window") when it performed conversion
// of strings with what it believes might be the source encoding?
// (Note: if UPGRADE_CPSTRINGS_SRCENC[A] is specified, this has no effect.)
UPGRADE_CPSTRINGS_SILENT = NO

// The source encoding for non-ASCII identifiers, comments, etc..
// UPGRADE_CPSTRINGS_SRCENC = "CP855"; // cyrillic OEM codepage

// Some bits of data were stored in a separate encoding than the
// comments (i.e., they were stored in the local ANSI codepage,
// not the local OEM codepage). This lets you specify that
// encoding.
// UPGRADE_CPSTRINGS_SRCENCA = "windows-1251"; // cyrillic ANSI codepage

// NOTE: it's possible to pass config directives to IDA directly
// from the command line. The following terminal commands are
// therefore valid:
//
// * Have IDA to silently perform conversion, using whatever
//   it thinks might be the source encoding (guessed from the system):
// $ ida -dUPGRADE_CPSTRINGS_SILENT=YES some695.idb
//
// * Have IDA to silently perform conversion, using Cyrillic
//   OEM codepage as the source encoding:
// $ ida -dUPGRADE_CPSTRINGS_SRCENC=\"CP855\" some695.idb
// (notice the escaping of the CP855 string. It's necessary
// because config directives on the command line are parsed
// using the exact same C-style lexer as the config file, and
// thus double-quotes are expected around a string literal.)


// Lumina related parameters
//LUMINA_HOST = "lumina.hex-rays.com";
//LUMINA_PORT = 443
//LUMINA_MIN_FUNC_SIZE = 32

// Telemetry reporting related parameters
//TLM_HOST = "tlm.hex-rays.com";
//TLM_PORT = 443

#else                   // first pass ends here


//=========================================================================
//
//                      S E C O N D   P A S S
//
//=========================================================================
//      Second pass starts here.
//      At the second pass IDA defines a macro "__<processor>__"
//      For example, if the user specified 'z80' processor,
//      then __Z80__ will be defined.
//      (note that the processor name is converted to uppercase)
//      Also, a processor module file name is used to create a macro
//      "__<idpname>__". For example, IBM PC loader defines "__PC__" symbol.
//      These macros can be used for processor specific tuning, for example:
//
//      #ifdef __Z80__
//        MAX_AUTONAME_LEN = 8
//      #endif
//
//-------------------------------------------------------------------------
//
//      General parameters for all processors
//      (processor specific parameters are below)
//
//-------------------------------------------------------------------------

PACK_DATABASE           = 1             // 0 - don't pack at all
                                        // 1 - pack database (store)
                                        // 2 - pack database (deflate)
CREATE_BACKUPS          = NO            // Create database backups
COLLECT_GARBAGE         = NO            // Collect garbage when saving the database
// ABANDON_DATABASE        = NO            // Set to YES to not save database on exit (useful in batch mode)
STORE_USER_INFO         = NO            // Store information about the user
                                        // who created the database.
                                        // Use del_user_info() IDC function to delete
                                        // user info in existing databases.

// Program to visualize graphs

#ifdef __NT__
// program to run after generating the graph. The filename is added at the end
GRAPH_VISUALIZER        = "qwingraph.exe -remove -timelimit 10"
// format of graph files to generate. Possible values: "GDL" and "DOT"
GRAPH_FORMAT            = "GDL"
// GRAPH_VISUALIZER        = "C:\\PROGRA~2\\GRAPHV~1.3\\BIN\\dotty.exe"
// GRAPH_FORMAT            = "DOT"
#else
#ifdef __LINUX__
GRAPH_VISUALIZER        = "qwingraph -remove -timelimit 10"
GRAPH_FORMAT            = "GDL"
//GRAPH_VISUALIZER        = "/usr/bin/dotty"
//GRAPH_FORMAT            = "DOT"
#else # __MAC__
GRAPH_VISUALIZER        = "qwingraph -remove -timelimit 10"
GRAPH_FORMAT            = "GDL"
#endif
#endif

//-------------------------------------------------------------------------
//
//      Analysis parameters
//
//-------------------------------------------------------------------------

ENABLE_ANALYSIS         = YES   // Background analysis is enabled

SHOW_INDICATOR          = YES   // Show background analysis indicator

#define AF_CODE         0x00000001      // Trace execution flow
#define AF_MARKCODE     0x00000002      // Mark typical code sequences as code
#define AF_JUMPTBL      0x00000004      // Locate and create jump tables
#define AF_PURDAT       0x00000008      // Control flow to data segment is ignored
#define AF_USED         0x00000010      // Analyze and create all xrefs
#define AF_UNK          0x00000020      // Delete instructions with no xrefs
#define AF_PROCPTR      0x00000040      // Create function if data xref data->code32 exists
#define AF_PROC         0x00000080      // Create functions if call is present
#define AF_FTAIL        0x00000100      // Create function tails
#define AF_LVAR         0x00000200      // Create stack variables
#define AF_STKARG       0x00000400      // Propagate stack argument information
#define AF_REGARG       0x00000800      // Propagate register argument information
#define AF_TRACE        0x00001000      // Trace stack pointer
#define AF_VERSP        0x00002000      // Perform full SP-analysis. (\ph{verify_sp})
#define AF_ANORET       0x00004000      // Perform 'no-return' analysis
#define AF_MEMFUNC      0x00008000      // Try to guess member function types
#define AF_TRFUNC       0x00010000      // Truncate functions upon code deletion
#define AF_STRLIT       0x00020000      // Create string literal if data xref exists
#define AF_CHKUNI       0x00040000      // Check for unicode strings
#define AF_FIXUP        0x00080000      // Create offsets and segments using fixup info
#define AF_DREFOFF      0x00100000      // Create offset if data xref to seg32 exists
#define AF_IMMOFF       0x00200000      // Convert 32bit instruction operand to offset
#define AF_DATOFF       0x00400000      // Automatically convert data to offsets
#define AF_FLIRT        0x00800000      // Use flirt signatures
#define AF_SIGCMT       0x01000000      // Append a signature name comment for recognized anonymous library functions
#define AF_SIGMLT       0x02000000      // Allow recognition of several copies of the same function
#define AF_HFLIRT       0x04000000      // Automatically hide library functions
#define AF_JFUNC        0x08000000      // Rename jump functions as j_...
#define AF_NULLSUB      0x10000000      // Rename empty functions as nullsub_...
#define AF_DODATA       0x20000000      // Coagulate data segs at the final pass
#define AF_DOCODE       0x40000000      // Coagulate code segs at the final pass
#define AF_FINAL        0x80000000      // Final pass of analysis
ANALYSIS        = 0xDFFF9FF7ULL // This value is combination of the bits defined
                                // above

#define AF2_DOEH        0x00000001      /// Handle EH information
#define AF2_DORTTI      0x00000002      /// Handle RTTI information
#define AF2_MACRO       0x00000004      /// Try to combine several instructions
                                        /// into a macro instruction
ANALYSIS2       = 0x00000007ULL // This value is combination of the bits defined
                                // above

FLAT_OFF32              = NO    // treat REF_OFF32 as 32-bit offset (otherwise try SEG16:OFF16 for 16bit segments)

//-------------------------------------------------------------------------
//
//      Text representation
//
//-------------------------------------------------------------------------

OPCODE_BYTES            = 10   // display this many instruction/data bytes (0 to disable)
                              // The 'default' configuration in the registry may
                              // override this value
INDENTION               = 0  // Indentation of instructions
                              // The 'default' configuration in the registry may
                              // override this value
COMMENTS_INDENTION      = 40  // Indentation of short comments
MAX_TAIL                = 16  // Tail depth (used to gather xref info)
MAX_XREF_LENGTH         = 80  // Right margin for cross-references
MAX_DATALINE_LENGTH     = 100  // Right margin for data directives (db,dw, etc)
SHOW_AUTOCOMMENTS       = NO  // Display comments for every instruction?
                              // Please note that there is another definition
                              // for IBM PC below
SHOW_BASIC_BLOCKS       = YES  // Generate an empty line at the end of a basic block
SHOW_BORDERS            = YES // Borders between data/code
SHOW_EMPTYLINES         = YES // Generate empty lines to make disassembly more readable
SHOW_LINEPREFIXES       = YES // Show line prefixes (like 1000:0000)
SHOW_SEGMENTS           = YES // Show segments in addresses
USE_SEGMENT_NAMES       = YES // Show segment names instead of numbers
SHOW_REPEATABLE_COMMENTS= YES // Show repeatable comments (disabling this increases IDA speed)
SHOW_SP                 = NO  // Show stack pointer at the start of lines
                              // The 'default' configuration in the registry may
                              // override this value
SHOW_SUSPICIOUS         = NO  // Show <void> marks (the red/orange color is bright enough)
SHOW_XREFS              = 15   // Show 2 cross-references (the rest is accessible by Ctrl-X)
SHOW_XREF_FUNC          = YES // Show function offsets in xrefs
SHOW_XREF_TYPES         = YES // Show xref type marks
SHOW_XREF_VALUES        = YES // If not, xrefs are displayed as "..."
SHOW_SEGXREFS           = YES // Show segment part of addresses in cross-references
SHOW_SOURCE_LINNUM      = YES  // Show source line numbers
SHOW_TRYBLOCKS          = YES // Show try block line information
SHOW_ASSUMES            = YES // Generate 'assume' directives
SHOW_ORIGINS            = YES // Generate 'org' directives
SHOW_REFCMTS            = 1   // Show 1 reference to ASCII strings or demangled names
                              // (the rest is accessible by Ctrl-J)

DEL_CODE_COMMENTS       = YES // Delete a comment attached to an instruction
                              // when the instruction is deleted
MAX_ITEM_LINES          = 25000 // Maximum number of lines for one item (one instruction or data)

//-------------------------------------------------------------------------
//      Colors
//-------------------------------------------------------------------------
#ifdef __GUI__
//PROLOG_COLOR = 0xF4FFFF            // light yellow
//EPILOG_COLOR = 0xF0FFFF            // light yellow
//SWITCH_COLOR = 0xE0E0FF            // pink
#endif

//-------------------------------------------------------------------------
//
//      Floating point numbers
//
//-------------------------------------------------------------------------
FPNUM_DIGITS            = 0   // If non-zero, specifies the number of digits printed
                              // after the decimal point. The printed number may be
                              // truncated if necessary.
                              // If FPNUM_DIGITS is non-zero, FPNUM_LENGTH must be non-zero too

FPNUM_LENGTH            = 6   // If FP_DIGITS is non-zero:
                              //   specifies the desired length of output string.
                              //   IDA will print the number in regular (non-scientific)
                              //   notation if possible.
                              // else
                              //   controls the notation used to print the number:
                              //   if the abs(number exponent) <= FPNUM_LENGTH
                              //     print in regular notation
                              //   else
                              //     print in scientific notation

// Example: to display numbers in reasonable range (0.00001..10000.0) nicely
//      FPNUM_DIGITS=0
//      FPNUM_LENGTH=5
// Too big and too small numbers will be printed using the scientific notation

// Example: to display numbers nicely formatted with constant width (8) and
//          constant decimal point position(3):
//      FPNUM_DIGITS=3
//      FPNUM_LENGTH=8
// IDA will print numbers in regular notation if possible.
// Attention, this setting will truncate all values to 3 digits after the decimal point

// Example: print numbers in scientific notation
//      FPNUM_DIGITS=0
//      FPNUM_LENGTH=0

// Example: forbidden combination:
//      FPNUM_DIGITS=5
//      FPNUM_LENGTH=0

//-------------------------------------------------------------------------
//
//      Text representation in the graph mode
//
//-------------------------------------------------------------------------
GRAPH_COMMENTS_INDENTION    = 24        // Indention of short comments
GRAPH_INDENTION             = 0         // Indention of instructions
GRAPH_MARGIN                = 40        // Max node width
GRAPH_SHOW_LINEPREFIXES     = NO        // Show line prefixes (like 1000:0000)
GRAPH_SHOW_XREFS            = 0         // Show no xrefs (use node title button for them)
GRAPH_OPCODE_BYTES          = 0         // don't display instruction/data bytes

//-------------------------------------------------------------------------
//
//      ASCII strings & names
//
//-------------------------------------------------------------------------

STRLIT_GENNAMES          = YES          // Generate names when making
                                        // an ASCII string
STRLIT_TYPE_AUTO         = YES          // Should IDA mark generated ascii names
                                        // as 'autogenerated'?
                                        // Autogenerated names will be deleted
                                        // when the ascii string is deleted
                                        // Also, they are displayed with the
                                        // same color as dummy names.
STRLIT_LINEBREAK         = '\n'         // This char forces IDA
                                        // to start a new line
STRLIT_PREFIX            = "a"          // This prefix is used when a new
                                        // name is generated

#define STRTYPE_C         0             // C-style string.
#define STRTYPE_C_16      1             // Zero-terminated 16bit chars
#define STRTYPE_C_32      2             // Zero-terminated 32bit chars
#define STRTYPE_PASCAL    4             // Pascal-style, one-byte length prefix
#define STRTYPE_PASCAL_16 5             // Pascal-style, 16bit chars, one-byte length prefix
#define STRTYPE_LEN2      8             // Pascal-style, two-byte length prefix
#define STRTYPE_LEN2_16   9             // Pascal-style, 16bit chars, two-byte length prefix
#define STRTYPE_LEN4      12            // Pascal-style, two-byte length prefix
#define STRTYPE_LEN4_16   13            // Pascal-style, 16bit chars, two-byte length prefix
STRLIT_STYLE             = STRTYPE_C    // Default is C-style

STRLIT_SERIAL            = NO           // Serial names are disabled
STRLIT_SERNUM            = 0            // Number to start serial names
STRLIT_ZEROES            = 0            // Number of leading zeroes in
                                        // serial names
STRLIT_COMMENT           = YES          // Generate auto comment for
                                        // ascii references. This option will
                                        // display the beginning of ascii string
                                        // at the instruction which refers
                                        // to the string
STRLIT_SAVECASE          = NO           // Preserve case of ascii strings for identifiers

        // type of generated names: (dummy names)
#define NM_REL_OFF      0
#define NM_PTR_OFF      1
#define NM_NAM_OFF      2
#define NM_REL_EA       3
#define NM_PTR_EA       4
#define NM_NAM_EA       5
#define NM_EA           6
#define NM_EA4          7
#define NM_EA8          8
#define NM_SHORT        9
#define NM_SERIAL       10
DUMMY_NAMES_TYPE        = NM_EA

MAX_AUTONAME_LEN        = 15            // Maximal length of new autogenerated names
                                        // (you may specify values up to 511)
        //
        // NOTE: As far as I know some assemblers can't handle such
        // a long names. For example, Table Driven Assembler
        // supports names' length up to 13.
        //      BE CAREFUL!

// Types of names that must be included into the list of names
// (this list usually appears by pressing Ctrl-L)
//      normal    1
//      public    2
//      auto      4
//      weak      8

LIST_NAMES              = 0x07  // default: include normal, public, auto

//-------------------------------------------------------------------------

//      Representation of demangled names
//      There are two predefined forms of demangled names: short and long forms.
//      Form of a demangled names is determined by combination of bits.
//      Each bit inhibits or permits some part of the demangled name.

                                    // Pointer modifiers:
#define MNG_DEFNEAR      0x00000000 //   inhibit near, display everything else
#define MNG_DEFNEARANY   0x00000001 //   inhibit near/__ptr64, display everything else
#define MNG_DEFFAR       0x00000002 //   inhibit far, display everything else
#define MNG_NOPTRTYP16   0x00000003 //   inhibit everything (disables vc7-extensions)
#define MNG_DEFHUGE      0x00000004 //   inhibit huge, display everything else
#define MNG_DEFPTR64     0x00000005 //   inhibit __pt64, display everything else
                                    //   ATT: in 64bit must be + MNG_NOTYPE|MNG_NOCALLC
#define MNG_DEFNONE      0x00000006 //   display all pointer modifiers
#define MNG_NOPTRTYP     0x00000007 //   inhibit all pointer modifiers

#define MNG_NODEFINIT    0x00000008 // Inhibit everything except the main name
                                    // This flag is not recommended
                                    // for __fastcall/__stdcall GCC3 names
                                    // because there is a high probablity of
                                    // incorrect demangling. Use it only when
                                    // you are sure that the input is a
                                    // cygwin/mingw function name
#define MNG_NOUNDERSCORE 0x00000010 // Inhibit underscores in __ccall, __pascal... +
#define MNG_NOTYPE       0x00000020 // Inhibit callc&based
#define MNG_NORETTYPE    0x00000040 // Inhibit return type of functions
#define MNG_NOBASEDT     0x00000080 // Inhibit base types
                                    //   NOTE: also inhibits "__linkproc__"
#define MNG_NOCALLC      0x00000100 // Inhibit __pascal/__ccall/etc
#define MNG_NOPOSTFC     0x00000200 // Inhibit postfix const
#define MNG_NOSCTYP      0x00000400 // Inhibit public/private/protected
#define MNG_NOTHROW      0x00000800 // Inhibit throw description
#define MNG_NOSTVIR      0x00001000 // Inhibit "static" & "virtual"
#define MNG_NOECSU       0x00002000 // Inhibit class/struct/union/enum
#define MNG_NOCSVOL      0x00004000 // Inhibit const/volatile/restrict
                                    //   NOTE: also inhibits "__unaligned"
#define MNG_NOCLOSUR     0x00008000 // Inhibit __closure for borland
#define MNG_NOUNALG      0x00010000 // Inhibit __unaligned (see NOCSVOL)
#define MNG_NOMANAGE     0x00020000 // Inhibit __pin/__box/__gc for ms(.net)
#define MNG_SHORT_S      0x00100000 // signed (int) is displayed as s(int)
#define MNG_SHORT_U      0x00200000 // unsigned (int) is displayed as u(int)
#define MNG_ZPT_SPACE    0x00400000 // Display space after comma in the arglist
#define MNG_DROP_IMP     0x00800000 // Inhibit __declspec(dllimport)
#define MNG_IGN_ANYWAY   0x02000000 // Ingore '_nn' at the end of name
#define MNG_IGN_JMP      0x04000000 // Ingore 'j_'  at the beginning of name
#define MNG_MOVE_JMP     0x08000000 // Move 'j_' prefix to the demangled name
                                    // If both MNG_IGN_JMP and MNG_MOVE_JMP
                                    // are set then move the prefix only if
                                    // the name was not truncated

ShortNameForm   =       0x0EA3BE67      // short form of demangled names
LongNameForm    =       0x06400007      // long  form of demangled names

#define DEMNAM_CMNT  0                  // comments
#define DEMNAM_NAME  1                  // regular names
#define DEMNAM_NONE  2                  // don't display

DemangleNames   = DEMNAM_CMNT           // Show demangled names as comments

DEMNAME_FIRST   = NO                // YES means that demangled name overrides
                                    // type info if both are present

//-------------------------------------------------------------------------
//
//      Character translations and allowed character lists
//
//-------------------------------------------------------------------------

// the following characters are allowed in strings, i.e.
// in order to find end of a string IDA looks for a character
// which doesn't belong to this array:
// Note about CURRENT_CULTURE:
//  - if the IDB's default encoding for 1-byte/symbol strings, is not
//    UTF-8, a "culture" will be derived from it. E.g., "windows-1252"
//    will yield culture "Latin_1".
//  - this cannot be done automatically for UTF-8, since UTF-8 covers
//    the whole Unicode codepoints space.
//  - regardless of whether a "culture" can be derived from the default
//    encoding or not, this can be overridden by the CULTURE configuration
//    property (see below)
//  - the CURRENT_CULTURE directive tells IDA to consider all
//    codepoints that are defined as part of that culture, as valid
//    in the string literals.
//  - this applies to codepoints >= 0x80
//  - a "culture" refers to the name of a .clt file in the cfg/ directory.
//    E.g., "Latin_1" will correspond to the "Latin_1.clt" file.
//    In this case, the culture will contain all codepoints specified by
//    the file.
//    (It is worth pointing out that a culture file can, itself, include
//    other culture file(s))
StrlitChars =
        "\r\n\a\v\b\t\x1B"
        " !\"#$%&'()*+,-./0123456789:;<=>?"
        "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"
        "`abcdefghijklmnopqrstuvwxyz{|}~",
        // Those should be part of the 'Latin_1_Supplement' culture
        // u00A1, // INVERTED EXCLAMATION MARK
        // u00BF, // INVERTED QUESTION MARK
        u00A9, // COPYRIGHT SIGN
        u00AE, // REGISTERED SIGN
        u20AC, // EURO SIGN
        u00B0, // DEGREE SIGN
        u2013, // EN DASH
        u2014, // EM DASH

        /// This would bring all the codepoints from the 'Latin.clt' file
        // Culture_Latin_1,

        /// This would bring all the _letters_ of the "Greek and Coptic"
        /// Unicode block
        // Block_Greek_and_Coptic,

        CURRENT_CULTURE;


// The default 'culture' to use. Using -DCULTURE="foo" is a convenient way of
// specifying the culture for just one input file.
// CULTURE="Latin_1"; // all codepoints in Latin_1.clt file
// CULTURE="all"; // all letters of all Unicode blocks, plus all codepoints in .clt files


// The default 1-byte encoding to use
// ENCODING="UTF-8"
// ENCODING="windows-1252"


// the following characters are allowed in user-defined names:

NameChars =
        "$?@"           // asm specific character
        "_0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz",
        // This would enable common Chinese characters in identifiers:
        // Block_CJK_Unified_Ideographs,
        CURRENT_CULTURE;


// the following characters are allowed in mangled names.
// they will be substituted with underscore during output if names
// are output in a mangled form.

MangleChars = "$:?([.)]"        // watcom
              "@$%?"            // microsoft
              "@$%&";           // borland


// the following characters are allowed in type names.

TypeNameChars =
        "_:$()`'{}"
        "_0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

//-------------------------------------------------------------------------
//      Built-in C parser parameters
//-------------------------------------------------------------------------

// Compiler-dependent settings: the folowing variables should be defined:
// HEADER_PATH - list of include directories
// separated by ';' on Windows and ':' on Unix
// PREDEFINED_MACROS - list of predefined macros
CC_PARMS = {
  vc {                             // Visual C++
     HEADER_PATH = "/Program Files/Microsoft Visual Studio/VC98/include"
     PREDEFINED_MACROS   = "_cdecl=__cdecl;"
                           "_pascal=__pascal;"
                           "_huge=__huge;"
                           "_near=__near;"
                           "_far=__far;"
                           "__inline=;"
                           "_inline=;"
                           "inline=;"
                           "CM_WINNT;"
                           "MPR50;"
                           "_INTEGRAL_MAX_BITS=64;"
                           "_MSC_VER=1400;"
                           "_CHAR_UNSIGNED=1;"
                           "_M_IX86=300;"
                           "__MT__=1;"
                           "__TLS__=1;"
                           "_Windows=1;"
                           "__WIN32__=1;"
                           "_WIN32_WINNT=0x0500;"
                           "WINVER=0x0500;"
                           "_WIN32=1;"
                           "OLEDBVER=0x0250;"
                           "SECURITY_WIN32;"
                           "WIN32_SUPPORT;"
                           "DBNTWIN32;"
                           "W32SUT_32;"
  }
  gcc {                            // GNU C++
#ifdef __NT__
     HEADER_PATH = "/gcc/usr/local/include;/gcc/usr/include"
#else
     HEADER_PATH = "/usr/local/include:/usr/include"
#endif
     PREDEFINED_MACROS   = "__GNUC__=4;"
                           "__CHAR_BIT__=8;"
                           "unix=1;"
                           "__unix=1;"
                           "__unix__=1;"
                           "__ELF__=1;"
  }
  bcc {                            // Borland C++
    PREDEFINED_MACROS    = "__BORLANDC__=0x560;"
  }
  delphi {                         // Delphi
    PREDEFINED_MACROS    = "__BORLANDC__=0x550;"
  }
  watcom {                         // Watcom C++
    PREDEFINED_MACROS    = "__WATCOMC__=1100;"
  }
  visage {                         // Visual Age C++
    HEADER_PATH = "/usr/include"
    PREDEFINED_MACROS    = "__IBMC__=1110;"
                           "__IBMCPP__=1110;"
  }
  default {
     HEADER_PATH = ""
     PREDEFINED_MACROS   = ""
  }
}

// The namespace list is used to avoid failures caused by an heuristic rule
// that derives function types based on their names. For a name like A::B()
// it yields A::B(A*this). However, this rule should be turned off for namespace
// names, for example for std::terminate(). See also AF_MEMFUNC

CPP_NAMESPACES = "std;stdext;tr1;tr2;boost;boost::system;_STL;ATL;QT;"
                 "__gnu_cxx;__cxxabiv1;_com_util;"
                 "allocators;chrono;Concurrency;concurrency;details;Details;"
                 "direct3d;errc;fast_math;graphics;io_errc;msl;Platform;"
                 "precise_math;regex_constants;threads;utilities;Windows;"
                 "System;Sysutils;Classes;Controls;ExtCtrls;Forms;Menus;Comobj;Mapi;"
                 "CDO;Gdiplus;DllExports;MSXML2;MSXML6;BDATuningModel;";


// The maximum length of the list of trusted idb files.
// An idb file is considered as trusted if the user launched the debugger
// with it and saved the idb.
// If the current idb is marked as untrusted, IDA asks the user for a confirmation
// that s/he really wants to launch the debugger.
// The list of trusted databases (only md5 checksums of the idb header)
// is kept in %appdata%/Hex-Rays/IDA Pro/trusted_idb_list.bin
// If this parameter is zero, all idbs are considered as trusted.

MAX_TRUSTED_IDB_COUNT = 1024

// If the number of referers to a function tail reaches this
// amount, automatically hide (i.e., collapse) the function tail.
AUTOHIDE_FUNCTAIL_NREFS = 20

//-------------------------------------------------------------------------
//      Beautify names
//-------------------------------------------------------------------------

APPLY_NAME_REGEXPS = YES                // use rules from goodname.cfg

//-------------------------------------------------------------------------
//      Processor specific parameters
//-------------------------------------------------------------------------
#ifdef __PC__                           // INTEL 80x86 PROCESSORS

//
// Location of Microsoft Debugging Engine Library (dbgeng.dll)
// This value is used by both the windmp (dump file loader) and the windbg
// debugger module.
// Only use this setting in case of a non-standard install location.
// (note: make sure there is a semicolon at the end)

//DBGTOOLS = "C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\";

USE_FPP                 = YES           // Floating Point Processor
                                        // instructions are enabled

// IBM PC specific analyzer options

PC_ANALYZE_PUSH         = YES           // Convert immediate operand of "push" to offset
                                        //
                                        //      In sequence
                                        //
                                        //              push    seg
                                        //              push    num
                                        //
                                        //      IDA will try to convert <num> to offset.
                                        //
PC_ANALYZE_NOP          = NO            // Convert db 90h after "jmp" to "nop"
                                        // Now it is better to turn off this option
                                        // because the final pass of the analysis will
                                        // convert 90h to nops more intelligently.
                                        //
                                        //      Sequence
                                        //
                                        //              jmp     short label
                                        //              db      90h
                                        //
                                        //      will be converted to
                                        //
                                        //              jmp     short label
                                        //              nop
                                        //
PC_ANALYZE_MOVOFF       = YES           // Convert immediate operand of "mov reg,..." to offset
                                        //
                                        //      In sequence
                                        //
                                        //              mov reg,    num
                                        //              mov segreg, immseg
                                        //
                                        //      where
                                        //        reg    - any general register
                                        //        num    - a number
                                        //        segreg - any segment register
                                        //        immseg - any form of operand representing a segment paragraph
                                        //
                                        //      <num> will be converted to an offset
                                        //
PC_ANALYZE_MOVOFF2      = YES           // Convert immediate operand of "mov memory,..." to offset
                                        //
                                        //      In sequence
                                        //
                                        //              mov x1, num
                                        //              mov x2, seg
                                        //
                                        //      where
                                        //              x1,x2 - any references to memory
                                        //
                                        //      <num> will be converted to an offset
                                        //
PC_ANALYZE_ZEROINS      = NO            // Disassemble zero opcode instructions
                                        //
                                        //      These instructions include:
                                        //
                                        //              00 00   add [bx+si], al
                                        //              00 00   add [eax], al
                                        //
                                        //      Usually this options is disabled
                                        //
PC_ANALYZE_BRTTI        = YES           // Advanced analysis of Borland's RTTI
                                        //
                                        //      This option allows ida to test and create RTTI structures.
                                        //      The analisys is triggered by renaming a location.
                                        //      If the new name can be demangled as Borland's RTTI descriptor name
                                        //      then the analisys is performed.
                                        //
PC_ANALYZE_UNKRTTI      = YES           // Check 'unknown_libname' for Borland's RTTI
                                        //
                                        //      This option allows IDA to test locations named as unknown_libname
                                        //      for RTTI structures. This option is meaningful only if the advanced
                                        //      analysis of RTTI is allowed.
                                        //
PC_ANALYZE_EXPFUNC      = YES           // Advanced analisys of catch/finally block
                                        //
                                        //      This option allows ida to check catch/finally exception blocks
                                        //
PC_ANALYZE_DIFBASE      = NO            // Allow references with different segment bases
                                        //
                                        //      This option allows IDA to display a reference to a symbol even if
                                        //      the reference value is not equal to the symbol value. For example,
                                        //      to refer to symbol \"x\" at 0000:0100 with expression 0010:0000
                                        //
PC_ANALYZE_NOPREF       = NO            // Don't display redundant instruction prefixes
                                        //
                                        //      This option makes the disassembly more readable by hiding the
                                        //      superfluous instruction prefixes which are not used in the
                                        //      instruction
                                        //
PC_ANALYZE_VXD          = YES           // Interpret int 20 as VxDcall
                                        //
                                        //      This option turns on interpretation of int 20h
                                        //      as a VxDcall/jump for 32-bit files
                                        //
PC_ANALYZE_FPEMU        = YES           // Enable FPU emulation instructions
                                        //
                                        //      This option turns on interpretation of int 3?h
                                        //      instructions as FPU emulation instructions
                                        //
PC_ANALYZE_SHOWRIP      = NO            // Explicit RIP-addressing
                                        //
                                        //      If this option is turned on, then RIP addressing is
                                        //      always represented with the RIP register
                                        //
                                        //              mov rax, [rip+1234]
                                        //
                                        //      Otherwise RIP addressing is replaced by the corresponding
                                        //      memory reference (when possible)
                                        //      This option is valid only for the 64-bit mode.
                                        //

PC_ANALYZE_NOSEH        = NO            // Disable SEH/EH analysis
                                        //      This option disables detection of Structured Exception (SEH)
                                        //      and C++ Exception (EH) handlers.

PC_ANALYZE_INT3STOP     = YES           // Analyze 'int 3' instructions
                                        //      If enabled, try to determine if execution stops after an int 3 instruction.
                                        //      For example, in the following code int 3 is likely a guard
                                        //      added by compiler to protect against return from a noret function:
                                        //
                                        //      call   __CxxThrowException@8
                                        //      int    3

PC_ANALYZE_AGGRJMPS     = YES           // Aggressively convert jumps to thunks
                                        //      If this option is on, almost any jump is converted to a thunk.
                                        //      Otherwise only the jumps to the existing functions are converted
                                        //      to thunk functions.

PC_ANALYZE_MAX_SIMPLEX_SIZE = 10000     // Do not use the simplex method if the
                                        // number of variables is greater than this.
                                        // It takes too long.

PE_MAKE_IDATA           = YES           // Create imports segment for PE files
PE_LOAD_RESOURCES       = NO            // Load resources for PE files
PE_CREATE_FLAT_GROUP    = NO            // Create FLAT group for PE files


SHOW_AUTOCOMMENTS       = NO // Don't display comments for every instruction

ANALYSIS        = 0xDFFFFFF7ULL // Enable 'noret' analysis
                                // Enable SP analysis

#endif // __PC__
//-------------------------------------------------------------------------
#ifdef __JAVA__
SHOW_SOURCE_LINNUM      = YES           // Show source line numbers
SHOW_BORDERS            = NO            // Borders between data/code
SHOW_LINEPREFIXES       = NO            // No Show line prefixes (1000:0000)
SHOW_SEGXREFS           = NO            // No Show segment part of addresses
                                        // in cross-references
DUMMY_NAMES_TYPE        = NM_SHORT      // See 'dummy names' for explanations
MAX_DATALINE_LENGTH     = 77            // Data directives (db,dw, etc):
                                        //   max length of argument string
SHOW_XREFS              = 1             // Show 1 cross-reference
COMMENTS_INDENTION      = 47            // Indention for on-line comments
//
// Table of characters which are allowed in class, field, and method names.
// This table is created dynamically by the java module.
// Java supports any unicode LetterOrDigit character as 'name'-character,
// but IDA curently does not support the unicode output. Theoretically it is
// possible to enable any character in the current codepage as 'namechar' but
// there will be a problem with IDA databases. A old database will look wrong
// if opened on a computer with a different codepage. For this reason
// only english letter, digits, '$' and '_' are allowed in the names.
// (see java langspec).
//
NameChars = "";
//
// Table of characters which are allowed in ASCII strings, i.e. in
// CONSTANT_String arguments, Source File Name, SourceDebugExtension, etc.
// This table not used by the java module - currently IDA accepts only
// characters < 0x7F (english characters) and encoded unicode character
// for the CURRENT locale (cidition: the locale is NOT mbcs, which means
// that japanese, thai, etc will not work)
//
StrlitChars = "";
//

JAVA_MULTILINE_DEBUG	=	YES	// Force a new line at every LF
					// in the '.debug' directive

JAVA_HIDE_STACKMAP	=	NO	// Hide '.stack' verification areas

JAVA_AUTO_STRING	=	NO	// Make 'prompt' string after every
					// LR in quoted strings

JAVA_ASMFILE_CONVERT	=	YES	// Create jasmin-compatible
                                        // asm-file and change
					// the encoding from OEM to ANSI
                                        // (jasmin expects ANSI encoding)

JAVA_ENABLE_ENCODING	=	YES     // Convert unicode characters in
                                        // strings constants to ascii
                                        // characters (for the current
 					// locale).

JAVA_NOPATH_ATTRIBUTE	=	NO	// If 'YES', filename in '.attribute'
					// directives is specified without path.

// options for loader

JAVA_UNKATTR_REQUEST	=	YES	// If the loaded file contains 'unknown
                                        // attributes' and the 'manual load' is off
                                        // then IDA will ask your permission to
                                        // store the attributes to an external
                                        // file

JAVA_UNKATTR_WARNING	=	YES	// Include information of 'unknown
					// attributes' (if they were not saved
					// into external files) in the problem
                                        // list

JAVA_STARTASM_LIST	=	NO	// Display mode for new java files:
                                        // YES: listing mode
                                        // NO: jasmin mode

#endif // __JAVA__

//-------------------------------------------------------------------------

#ifdef __ARM__

ANALYSIS        = 0xDF8FFFF7ULL // Disable AF_IMMOFF, AF_DREFOFF, AF_DATOFF
                                // Enable 'noret' analysis, AF_VERSP

NameChars =
        ".$"
        "_0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

ARM_SIMPLIFY     = YES          // Simplify instructions and replace them
                                // by pseudo-instructions

ARM_NO_PTR_DEREF = NO           // Disable using of =label notation
                                // This notation makes disassembly cleaner

ARM_NO_ARM_THUMB_SWITCH = NO    // No automatic ARM-THUMB switch

ARM_DISABLE_BL_JUMPS    = YES   // Disable detection of BL instructions used for long jumps (not calls) in Thumb mode

ARM_DEFAULT_ARCHITECTURE = "metaarm"; // Default architecture when not set by the loader. For details see documentation.

// handling of separated MOVW +MOVT pairs operating on the same register
#define MOVT_NONE 0 //do nothing (old behavior)
#define MOVT_ADDR 1 //only convert if resulting value is valid address
#define MOVT_ALL  2 //convert all pairs regardless of the value

ARM_MOVT_CONVERT = MOVT_ADDR

// ARM_DEFAULT_ARCHITECTURE = "ARMv7-A";

// for the vars below 0 means "no limit"
ARM_REGTRACK_VALS_SIZE   = 100  // max number of possible values of register
ARM_REGTRACK_OP_RECURS   = 100  // max level of recursion when emulating the execution of instructions
ARM_REGTRACK_BBLK_RECURS = 2000 // max level of recursion when unwinding the execution flow
ARM_REGTRACK_CACHE_SIZE  = 50000// max size of the cache for one register
ARM_REGTRACK_MAX_XREFS   = 256  // max number of xrefs
                                // the ARM module stops tracking registers if it finds more xrefs

#endif // __ARM__

//-------------------------------------------------------------------------
#ifdef __TMS320C6__
INDENTION       = 8             // Indention of instructions
NameChars =
        "$_0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";
ANALYSIS        = 0xDFEF9FF7ULL // All except AF_DREFOFF
#endif // __TMS320C6__

//-------------------------------------------------------------------------
#ifdef __TMS320C54__

TMS320C54_IO   =  YES		    // Use I/O definitions from the configuration
								// file in macro instructions.

TMS320C54_MMR  =  YES			// Replace addresses by an equivalent memory
								// mapped register.

TMS320C54_DSEG =  0x10000		// Default data segment address

#endif // __TMS320C54__

//-------------------------------------------------------------------------
#ifdef __PPC__          // PowerPC processor

NameChars =
        "_0123456789."
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";
                        // preserve the following characters in
                        // names (AIX assembler has .rename directive)
MangleChars = "!@#$%^&*()+-=[]\\{}|;':,/<>?`~ ";

ANALYSIS        = 0xDFFFFFB7ULL // Don't create function if data xref data->code32 exists
                                // (AIX XCOFF has many references from data
                                //  segment to strings in the code segment)
                                // Enable 'noret' analysis
                                // Enable SP analysis

DUMMY_NAMES_TYPE = NM_EA

MAX_DATALINE_LENGTH = 250       // this stupid AIX assembler can't digest
                                // a string without a trailing zero
                                // and we are forced to display
                                // everything on one line

PPC_LISOFF       = NO           // Aggressively convert lis/addi pairs to
                                // offsets (only if they refer to an
                                // existing address)

PPC_CREATE_SUBI  = NO           // If enabled, IDA will replace addi
                                // instructions with negative values by
                                // subi pseudo-instructions

// extra instructions to decode
// NB! AltiVec, SPE, VMX128 and Paired Singles are all mutually exclusive

#define ISA_ALTIVEC     0x0001  // AltiVec SIMD instructions
#define ISA_SPE         0x0002  // SPE (Signal Processing Engine) instructions
#define ISA_RESERVED    0x0004
#define ISA_VMX128      0x0003  // VMX128 SIMD instructions (Xbox360)
#define ISA_PAIRED      0x0008  // Paired Singles instructions (Gekko)
#define ISA_SERVER      0x0100  // ISA Server environment (otherwise embedded)

PPC_ISA_SUPPORT       = 0x0101  // This value is combination of the bits above

// The following keywords can be used to specify TOC, SDA base, and MMIO base
// from idc scripts like this: process_config_line("PPC_TOC=0x123456");
//  PPC_TOC       - TOC (r2) address in the AIX or 64-bit System V ABI or
//                  SDA2 address in the Embedded System V ABI
//  PPC_SDA_BASE  - SDA (r13) address in the System V ABI
//  PPC_MMIO_BASE - MMIO base

// how to show references with SDA register (r13),
// non-trivial values (SDA/SIMPLIFY) may be used in the Embedded
// environment only and when the SDA base is set
#define PPC_SDAREFS_NO        0 // as usual: (var - <sda_base>)(r13)
#define PPC_SDAREFS_SDA       1 // show @sda, do not show base: var@sda(r13)
#define PPC_SDAREFS_SIMPLIFY  2 // w/o base register: var
PPC_SDAREFS = PPC_SDAREFS_NO

// for the vars below 0 means "no limit"
PPC_REGTRACK_VALS_SIZE   = 10   // max number of possible values of register;
PPC_REGTRACK_OP_RECURS   = 100  // max level of recursion when emulating
                                // the execution of instructions;
PPC_REGTRACK_BBLK_RECURS = 2000 // max level of recursion when unwinding
                                // the execution flow;
PPC_REGTRACK_CACHE_SIZE  = 5000 // max size of the cache for one register;

PPC_FIX_GNU_VLEADRELOC_BUG = NO // There was a bug in GNU toolchain for PPC. It swaps relocs
                                // R_PPC_VLE_HA16A and R_PPC_VLE_HA16D (and also some others).
                                // See https://sourceware.org/bugzilla/show_bug.cgi?id=20744
                                // This bug is fixed in 2.28
                                // Set this var to process relocs R_PPC_VLE.*[AD] as GNU loader does.

#endif  // __PPC__

//-------------------------------------------------------------------------
#ifdef __80196__                // Intel 80196 processor

DUMMY_NAMES_TYPE = NM_SHORT

#endif  // __80196__

//-------------------------------------------------------------------------
#ifdef __I51__                  // Intel 8051, 80251 processors

DUMMY_NAMES_TYPE = NM_SHORT

#endif  // __I51__

//-------------------------------------------------------------------------
#ifdef __PDP11__                  // Digital PDP-11 processor

NameChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_";

#endif  // __PDP11__

//-------------------------------------------------------------------------
#ifdef __SH3__                  // Hitachi SH3 processor

ANALYSIS        = 0xDFFF9FB7ULL // Don't create function if data xref data->code32 exists
                                // (PE execs have many Unicode strings in the code segment)

DUMMY_NAMES_TYPE = NM_EA

SH3_INLINE_IMMVALS = YES        // Put the immediates loaded from the literal pool into the instruction itself

#endif  // __SH3__

//-------------------------------------------------------------------------
#ifdef __MIPS__                 // MIPS processor

ANALYSIS        = 0xDFFFDFF7ULL
// Disabled:
// AF_PURDAT 0x00000008  Control flow to data segment is ignored
// AF_VERSP  0x00002000  Perform full SP-analysis. (\ph{verify_sp})
//!AF_ANORET 0x00004000  Perform 'no-return' analysis
// AF_DODATA 0x20000000  Coagulate data segs at the final pass

DUMMY_NAMES_TYPE = NM_EA

MIPS_MNEMONIC    = YES          // Use mnemonic register names
MIPS_SIMPLIFY    = YES          // Simplify instructions and replace them
                                // by pseudo-instructions
                                // NB: see also AF2_MACRO in the global option ANALYSIS2
MIPS_STRICT      = NO           // Strictly adhere to instruction specifications
MIPS_MACRO_RESPECT_XREFS = YES  // When looking back for the "lui" instruction,
                                // stop when an xrefed instruction is found
MIPS_MACRO_HIDDEN_R1 = YES      // Allow hidden modification of $1 in macros

MIPS_SIMPLIFY_GP = YES          // Simplify $gp expressions

LOOKBACK         = 16           // Look back up to 16 instructions to find
                                // LUI instruction

// ABI of the loaded binary:
// MIPS_DEFAULT_ABI = (o32|n32|n64)
// encoding of instructions when mips16==1
// MIPS_ENCODING = (MIPS16e|microMIPS)

// The MIPS_GP keyword can be used to specify the canonical (primary) $gp value
// from idc scripts like this: process_config_line("MIPS_GP=0x123456");

#endif  // __MIPS__

//-------------------------------------------------------------------------
#ifdef __PIC__                  // PIC processor

DUMMY_NAMES_TYPE = NM_NAM_OFF
PIC_SIMPLIFY = YES // Simplify instructions (use macros)

#endif  // __PIC__

//-------------------------------------------------------------------------
#ifdef __SPARC__                // SPARC processor

ANALYSIS         = 0xDFDF9FF7ULL// Disable AF_IMMOFF

DUMMY_NAMES_TYPE = NM_EA

SPARC_SIMPLIFY   = YES          // Simplify instructions and replace them
                                // by pseudo-instructions
SPARC_STRICT     = NO           // Strictly adhere to instruction specifications
SPARC_V8         = NO           // V8 architecture disassembly

LOOKBACK         = 16           // Look back up to 16 instructions to find
                                // SETHI instruction
#endif  // __SPARC__

//-------------------------------------------------------------------------
#ifdef __ALPHA__                // DEC Alpha processor

DUMMY_NAMES_TYPE = NM_EA

ALPHA_SIMPLIFY   = YES          // Simplify instructions and replace them
                                // by pseudo-instructions
ALPHA_STRICT     = NO           // Strictly adhere to instruction specifications
ALPHA_MNEMONIC   = NO           // Use mnemonic register names

LOOKBACK         = 16           // Look back up to 16 instructions to find
                                // SETHI instruction

#endif  // __ALPHA__

//-------------------------------------------------------------------------
#ifdef __HPPA__                 // HP PA-RISC processor

DUMMY_NAMES_TYPE = NM_EA

HPPA_SIMPLIFY    = YES          // Simplify instructions and replace them
                                // by pseudo-instructions
HPPA_MNEMONIC    = NO           // Use mnemonic register names
HPPA_PSW_W       = NO           // Consider programs as 64bit?

LOOKBACK         = 16           // Look back up to 16 instructions to find
                                // ADDIL/LDIL instructions

NameChars =
        "_0123456789."
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

SHOW_BASIC_BLOCKS       = YES   // Generate an empty line at the end of basic blocks

#endif  // __HPPA__

//-------------------------------------------------------------------------
#ifdef __DSP56K__               // Motorola 56000 (5600x) processor

DUMMY_NAMES_TYPE        = NM_SHORT

PACK_DATABASE           = 2     // deflate

#endif  // __DSP56K__

//-------------------------------------------------------------------------
#ifdef __IA__                   // Intel Itanium IA64

DUMMY_NAMES_TYPE = NM_EA

NameChars =
        "_0123456789."
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

LOOKBACK         = 16           // Look back up to 16 instructions to find
                                // memory reference addresses
#endif  // __IA__

//-------------------------------------------------------------------------
#ifdef __CLI__                  // Microsoft.Net Common Language Infrastructure

NameChars =
        "$?@."           // asm specific character
        "_0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

MangleChars =
      "!#$%&'()*+,-./0123456789:;<=>?"
      "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_"
      "`abcdefghijklmnopqrstuvwxyz{|}~",
      u007F..u10FFFF & Category_Lo,
      u007F..u10FFFF & Category_Ll,
      u007F..u10FFFF & Category_Lu;


SHOW_BORDERS            = NO
SHOW_SEGMENT_BORDERS    = NO

INDENTION               = 4   // Indention of instructions
COMMENTS_INDENTION      = 40  // Indention of short comments
SHOW_LINEPREFIXES       = NO  // Show line prefixes (like 1000:0000)

#endif  // __CLI__

//-------------------------------------------------------------------------
#ifdef __MC68K__                // MC68K, 68xxx, 68000

ANALYSIS        = 0xDFFFDFF7ULL // Enable 'noret' analysis

MC68K_UNSIGNED_OPS      = YES   // Immediate operands are unsigned by default

#endif // __MC68K__

//-------------------------------------------------------------------------
#ifdef __MC6812__               // MC6812

#endif // __MC6812__

//-------------------------------------------------------------------------
#ifdef __H8__                   // H8

NameChars =
        "$?" // no '@' character
        "_0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

#endif  // __H8__

//-------------------------------------------------------------------------
#ifdef __H8500__                // H8/500

NameChars =
        "$?" // no '@' character
        "_0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

H8500_MIXED_SIZE        = YES

#endif  // __H8500__

//-------------------------------------------------------------------------
#ifdef __I960__                 // Intel 960

I960_STRICT             = YES

#endif  // __H8500__

//-------------------------------------------------------------------------
#ifdef __TRIMEDIA__             // TriMedia

TRIMEDIA_PSEUDO         = NO    // Don't use pseudo instructions since
                                // the assembler doesn't understand them

TRIMEDIA_GUARD0         = NO    // Allow R0 as the guard
                                // If this option is on, IDA will disassemble instructions
                                // with R0 as the guard\

TRIMEDIA_ONENOP         = YES   // Display NOP cycle one 1 line
                                // If this option is on, IDA will display a cycle with all
                                // NOP operations on one line

//ANALYSIS                = 0xDFCF9FF7ULL

#endif  // __TRIMEDIA__

//-------------------------------------------------------------------------
#ifdef __F2MC__                 // Fujitsu F2MC

F2MC_MACRO              = YES   // Use macro instructions

#endif  // __F2MC__

//-------------------------------------------------------------------------
#ifdef __TMS32054__             // Texas Instruments TMS320C54

TMS320C54_IO            = YES   // Use I/O definitions
TMS320C54_MMR           = YES   // Detect memory mapped registers

#endif  // __TMS32054__

//-------------------------------------------------------------------------
#ifdef __TRICORE__              // Infineon TRICORE

TRICORE_REGISTER_TRACKING = YES    // Enable register tracking

LOOKBACK                  = 16  // Look back up to 16 instructions to find
                                // memory reference addresses

// The following 2 parameters are to be used with process_config_line() IDC/IDAPython function:

// TRICORE_IORESP = 7              // The actions be carried out by TRICORE_DEVICE
//                                 // Bit combination of:
//                                 //   1 rename port names in memory
//                                 //   2 respect "area" directives
//                                 //   4 respect interrupt information
// TRICORE_DEVICE = "tc1766"       // Device name (see tricore.cfg)

#endif  // __TMS32055__

//-------------------------------------------------------------------------
#ifdef __TMS32055__             // Texas Instruments TMS320C55

TMS320C55_IO            = YES   // Use I/O definitions
TMS320C55_MMR           = YES   // Detect memory mapped registers

#endif  // __TMS32055__

//-------------------------------------------------------------------------
#ifdef __DALVIK__               // Dalvik Virtual Machine
ANALYSIS        = 0xDF9E9FF7ULL // Disable AF_IMMOFF, AF_DATOFF, AF_DODATA

#endif  // __DALVIK__


//-------------------------------------------------------------------------
#ifdef __S390__                 // IBM System/390

ANALYSIS        = 0xDFFFDFF7ULL // Enable 'noret' analysis

#endif // __S390__

//-------------------------------------------------------------------------
#ifdef __RISCV__                 // Risc-V

ANALYSIS        = 0xDFFFDFF7ULL // Enable 'noret' analysis

#endif // __RISCV__

//-------------------------------------------------------------------------
#ifdef __R32C__                 // R32C family, M16C module

ANALYSIS        = 0xDFDF9FF7ULL // Disable AF_IMMOFF

#endif // __R32C__

//-------------------------------------------------------------------------
#ifdef __RX__                   // Renesas RX

ANALYSIS        = 0xDFDF9FF7ULL // Disable AF_IMMOFF

#endif // __RX__


#endif // ____  second pass ends here
//-------------------------------------------------------------------------
//      User specific parameters
//-------------------------------------------------------------------------
//
//  If you don't want to modify IDA.CFG file then you can create a file called
//  IDAUSER.CFG and place additional parameters there.
//
//  The IDAUSER.CFG file should be placed in the following directory:
//      - unix:    $HOME/.idapro
//      - windows: %APPDATA%\Hex-Rays\IDA Pro
//
//  It will be called 2 times: in the first and second pass.
//  You can check the pass using
//      #ifdef ____
//        then it is the first pass
//      #else
//        it is the second pass
//      #endif
//
//  Some parameters must be defined in the first pass, some in the second.
//  See examples in this file.
//
#softinclude    <idauser.cfg>   // user defined macros can be
                                // defined in the 'idauser.cfg' file
                                // other parameters can be defined there too.
